# **Программное средство реализации онлайн-сервиса поиска автоперевозок в г.Минске**

**Описание проекта:**
Проект представляет собой программное средство для поиска автоперевозок в городе Минске. Система предназначена для автоматизации процесса подбора транспортных средств и водителей для перевозки грузов. Основой проекта является удобный сервис, который объединяет базу данных водителей, обеспечивая быстрый и точный поиск подходящих вариантов перевозки.

**Цели проекта:**
Главной целью проекта является снижение затрат времени на поиск автоперевозок в Минске. Данная система позволит сократить время на поиск и оформление перевозки, минимизировать ошибки при подборе транспорта и водителя.

**Основные возможности:**
Сервис предоставляет пользователям следующие функции: поиск доступных автомобилей для перевозки грузов с учетом веса, объема и маршрута; создание и управление заявками; расчет стоимости перевозки. Система также обеспечивает хранение и обработку информации о пользователях, водителях и транспортных средствах, а также возможность аналитики и формирования отчетов для оптимизации работы сервиса.

Ссылки на репозитории сервера и клиента
Сервер:https:[//github.com/vlada2202/TruckingServer.git](https://github.com/vlada2202/back.git)
Клиент:[https://github.com/vlada2202/TruckingClient.git](https://github.com/vlada2202/TruckingClient.git)
---

## **Содержание**

1. [Архитектура](#Архитектура)
	1. [C4-модель](#C4-модель)
	2. [Схема данных](#Схема_данных)
2. [Функциональные возможности](#Функциональные_возможности)
	1. [Диаграмма вариантов использования](#Диаграмма_вариантов_использования)
	2. [User-flow диаграммы](#User-flow_диаграммы)
3. [Пользовательский интерфейс](#Примеры экранов UI)
	1. [Пользовательский интерфейс](#Примеры экранов UI)
4. [Детали реализации](#Детали_реализации)
	1. [UML-диаграммы](#UML-диаграммы)
	2. [Спецификация API](#Спецификация_API)
	3. [Безопасность](#Безопасность)
	4. [Оценка качества кода](#Оценка_качества_кода)
5. [Тестирование](#Тестирование)
	1. [Unit-тесты](#Unit-тесты)
	2. [Интеграционные тесты](#Интеграционные_тесты)
6. [Установка и  запуск](#installation)
	1. [Манифесты для сборки docker образов](#Манифесты_для_сборки_docker_образов)
	2. [Манифесты для развертывания k8s кластера](#Манифесты_для_развертывания_k8s_кластера)
7. [Лицензия](#Лицензия)
8. [Контакты](#Контакты)

---
## **Архитектура**

### C4-модель

**Контейнерный уровень архитектуры ПС**
	
  <img width="701" height="785" alt="image" src="https://github.com/user-attachments/assets/a882d565-d3f5-40ac-9284-642a92a1fb99" />

Онлайн-сервис поиска автоперевозчиков в г. Минск представлен как программное средство CarDeal, которое обеспечивает взаимодействие между тремя основными внешними участниками: заказчиками автоперевозок, автоперевозчиками и оператором сервиса.

Система включает несколько ключевых контейнеров. Основной элемент для взаимодействия пользователей с системой – это клиентское приложение, которое предоставляет интерфейс для удобной работы заказчиков и перевозчиков с сервисом, позволяя им формировать и просматривать заявки, управлять услугами.
Для обработки бизнес-логики и управления данными используется API-приложение, построенное на Spring Framework. Этот контейнер отвечает за приём запросов от клиентского приложения, их обработку и выполнение бизнес-правил.
Хранение данных реализовано в базе данных MySQL, которая содержит всю необходимую информацию об услугах, пользователях, перевозчиках и т.д. Доступ к базе данных осуществляется только через Backend, что обеспечивает централизованный контроль за чтением и записью данных, а также целостность информации в системе.
   
**Компонентный уровень архитектуры ПС**
   
<img width="1177" height="819" alt="image" src="https://github.com/user-attachments/assets/c1070722-f29a-4674-9d8c-d756dbf19067" />

На компонентном уровне система CarDeal детализируется как набор логически выделенных модулей, каждый из которых реализует отдельную часть бизнес-логики.
Клиентское приложение формирует пользовательский интерфейс и отвечает за отправку запросов к серверу для работы с системой.

На стороне сервера реализованы несколько специализированных компонентов (контроллеров):

1 **AuthController** – отвечает за регистрацию и авторизацию пользователей, а также за валидацию и выдачу JWT-токенов для безопасного доступа.

2 **ReviewController** – управляет отзывами пользователей: добавление, редактирование, удаление и просмотр отзывов.

3 **AdminController** – предоставляет возможности модерации и управления системой, включая контроль пользователей и содержимого.

4 **RequestController** – осуществляет управление заявками пользователей: создание, редактирование, удаление и просмотр заявок.

5 **CarrierController** – предоставляет автоперевозчикам инструменты для управления своими услугами и взаимодействия с клиентами: добавление, редактирование, удаление и просмотр услуг.

Все контроллеры взаимодействуют с соответствующими сервисами (**UserService, ReviewsService, AdminService, RequestsService, CarriersService**), которые инкапсулируют бизнес-логику, обеспечивая работу с данными.

Данные хранятся в базе данных MySQL, включающей информацию о пользователях, заявках, услугах и отзывах. Доступ к данным осуществляется централизованно через сервисы и контроллеры, что обеспечивает целостность и безопасность работы системы.

### Схема данных

<img width="624" height="420" alt="image" src="https://github.com/user-attachments/assets/3e58cdfd-96c1-45db-812d-30458f260780" />


**Диаграмма состояний**

<img width="429" height="319" alt="image" src="https://github.com/user-attachments/assets/f1bd137a-1c6c-4424-872c-b30f3c67af9d" />

**Диаграмма деятельности**

<img width="242" height="588" alt="image" src="https://github.com/user-attachments/assets/2e2bba2a-e953-47af-a96b-840a15957107" />

**Диаграмма классов, отображающая структуру пакета app_user**

<img width="398" height="336" alt="image" src="https://github.com/user-attachments/assets/cd6197c8-1e6d-41e8-8581-1fa1136576b9" />

**Диаграмма классов, отображающая структуру пакета ordering_chat**

<img width="369" height="339" alt="image" src="https://github.com/user-attachments/assets/41a4349d-a55b-4ca7-b084-d5c2ce6c2322" />

**Диаграмма классов, отображающая структуру пакета ordering**

<img width="311" height="312" alt="image" src="https://github.com/user-attachments/assets/58112a30-bdb0-4e2c-ac4c-6bd3889110dd" />

---

## **Функциональные возможности**

### Диаграмма вариантов использования

<img width="471" height="295" alt="image" src="https://github.com/user-attachments/assets/73f6c9e7-ee90-462f-a473-9e72048e2614" />

Диаграмма вариантов использования отражает функциональные воз-можности программного средства для онлайн-сервиса поиска автоперевозчи-ков в г. Минске и взаимодействие между основными ролями системы. На диа-грамме представлены три актёра: заказчик автоперевозок, автоперевозчик и оператор сервиса, каждый из которых выполняет свои уникальные действия в рамках приложения.

Заказчик автоперевозок является основным пользователем системы, ко-торый может создавать заявки на перевозку, просматривать доступных авто-перевозчиков, отслеживать историю своих заявок, а также оставлять отзывы о выполненных перевозках. Эти варианты использования обеспечивают удоб-ство поиска и взаимодействия с перевозчиками.

Автоперевозчик имеет возможность управлять своими заявками – одобрять, отклонять или выполнять их. Также он может редактировать дан-ные своего профиля, добавлять транспортные средства и обновлять информа-цию о них. Данные функции направлены на поддержку актуальности инфор-мации и эффективное взаимодействие с заказчиками.

Оператор сервиса выполняет административные функции: управляет пользователями системы, просматривает аналитику по автоперевозчикам и осуществляет модерацию контента. Его роль обеспечивает стабильную и без-опасную работу сервиса, а также поддержание порядка в пользовательских данных и отзывах.


### User-flow диаграммы

**User-flow диаграмма для заказчика автоперевозок**

<img width="5470" height="3526" alt="image" src="https://github.com/user-attachments/assets/567c87d5-ad9d-4d36-911c-a2b660272523" />

На представленной user-flow диаграмме показан процесс взаимодействия заказчика автоперевозок с системой. Рамками выделены основные бизнес-процессы: авторизация и регистрация пользователя, а также создание за-явки на перевозку. Диаграмма отражает ключевые этапы: вход или регистрацию пользователя, формирование заявки, выбор или поиск перевозчика, отслеживание статуса заказа. Стрелками обозначены переходы между шагами, что позволяет наглядно проследить весь путь пользователя от входа в систему до завершения перевозки и получения результата.

**User-flow диаграмма для автоперевозчика**

<img width="6072" height="2816" alt="image" src="https://github.com/user-attachments/assets/c9809ab9-cc33-4003-9f20-c498aa89a42d" />

На данной user-flow диаграмме представлена последовательность дей-ствий автоперевозчика при работе с системой. Рамками выделены основные бизнес-процессы: вход и регистрация пользователя, управление услугами и работа с заявками. Диаграмма отображает логику переходов между экранами – от авторизации и добавления услуг до создания, редактирования и просмот-ра заявок. Такая структура позволяет проследить полный путь пользователя в системе, определить ключевые точки взаимодействия и оптимизировать ин-терфейс для удобства и понятности работы заказчика.

**User-flow диаграмма для оператора сервиса**

<img width="4328" height="2308" alt="image" src="https://github.com/user-attachments/assets/8db0b96c-5eba-472a-9a6c-227da5e33862" />

На представленной user-flow диаграмме показан процесс взаимодей-ствия оператора сервиса с системой. Рамками выделены основные бизнес-процессы: авторизация оператора сервиса, управление пользователями и управление каталогом автоперевозчиков. Диаграмма отражает шаги входа в систему, проверки данных, а также дальнейшие действия администратора – изменение ролей пользователей, редактирование и удаление услуг или карто-чек перевозчиков. Такая схема обеспечивает наглядное понимание структуры работы системы.

---

## **Пользовательский интерфейс**

### Примеры экранов UI

Ниже представлены примеры экранов программного средства. 

<img width="624" height="281" alt="image" src="https://github.com/user-attachments/assets/63488fff-c0d6-4dd7-bd52-5966042b9cce" />
<br>

<img width="551" height="248" alt="image" src="https://github.com/user-attachments/assets/42f00c90-4730-4ace-85d7-6e1800d4ed88" />
<br>

<img width="417" height="194" alt="image" src="https://github.com/user-attachments/assets/db298dd1-7707-44b9-9369-f936a8210557" />
<br>

<img width="470" height="184" alt="image" src="https://github.com/user-attachments/assets/46f6cdec-4c2b-4eac-beed-85b0600c509b" />
<br>

<img width="512" height="200" alt="image" src="https://github.com/user-attachments/assets/e9a75740-6ec9-4423-b085-530a8f525e39" />
<br>

<img width="624" height="221" alt="image" src="https://github.com/user-attachments/assets/308ff081-78e5-487e-b44f-0fafc4892985" />
<br>

<img width="624" height="305" alt="image" src="https://github.com/user-attachments/assets/a0abb2d1-f5a6-4071-95a2-d9ad9cbcbb7e" />
<br>

<img width="497" height="234" alt="image" src="https://github.com/user-attachments/assets/e7646c1d-2625-463f-8b00-13612438376d" />
<br>

<img width="467" height="223" alt="image" src="https://github.com/user-attachments/assets/430bbc07-5dbe-46a6-9074-11d1cd58bf13" />
<br>

<img width="489" height="207" alt="image" src="https://github.com/user-attachments/assets/4b74bae0-3873-49ab-9713-5dbe25f9aeb0" />
<br>

<img width="624" height="314" alt="image" src="https://github.com/user-attachments/assets/367bd4ae-c09c-48c6-bd2f-2670e5ab2513" />
<br>

<img width="624" height="313" alt="image" src="https://github.com/user-attachments/assets/98dae3a0-40fa-4ba1-97ac-bdc4df728367" />
<br>

## **Детали реализации**

### UML-диаграммы

Представить все UML-диаграммы , которые позволят более точно понять структуру и детали реализации ПС

### Спецификация API

Представить описание реализованных функциональных возможностей ПС с использованием Open API (можно представить либо полный файл спецификации, либо ссылку на него)

### Безопасность

За реализацию механизма аутентификации отвечают такие классы как, UserService, MyUserPrincipal, AuthController, AuthService, JwtProvider, SecurityConfiguration.
Класс **UserService** загружает пользователя из базы данных по логину и реализует интерфейс **UserDetailsService**, который используется **Spring Security** для проверки учетных данных. Класс **MyUserPrincipal** является обёрткой над сущностью **AppUser** и передаёт системе безопасности информацию о логине, пароле и ролях пользователя. Контроллер **AuthController** обрабатывает запро-сы на вход в систему по адресу /users/login и возвращает клиенту JWT-токен. Класс **AuthService** отвечает за создание этого токена и сбор информации о пользователе, а **JwtProvider** непосредственно генерирует и подписывает JWT-токен с помощью RSA-ключа. Конфигурационный класс **SecurityConfiguration** задаёт общие правила безопасности приложения, включая фильтры, CORS-настройки, обработку токенов и шифрование паролей. 
Вместе эти классы обеспечивают процесс аутентификации, авторизации и безопасного доступа к ресурсам приложения.


За реализацию механизма авторизации отвечают такие классы, как SecurityConfiguration, JwtProvider, UserController, MyUserPrincipal, CustomBearerTokenAuthenticationEntryPoint/CustomBearerT-kenAccessDeniedHandler.
Класс **SecurityConfiguration** определяет основные правила авторизации, настраивает фильтрацию запросов, обработку JWT-токенов и механизм про-верки прав доступа. Компонент **JwtProvider** формирует и проверяет токены, включая в них роли пользователя (authorities), что позволяет системе без-опасности определять уровень доступа при обращении к защищённым ресурсам. Класс **UserController** использует аннотации @Secured({ROLE}) для огра-ничения доступа к методам контроллера в зависимости от роли пользователя. Класс **MyUserPrincipal** передаёт роли (GrantedAuthority) из сущности пользо-вателя в контекст безопасности Spring Security, обеспечивая корректное сопоставление прав. Дополнительные классы – **CustomBearerTokenAuthenticationEntryPoint** и **CustomBearerTokenAccessDeniedHandler** – обрабатывают ошибки доступа, возникающие при отсутствии авторизации или при недостаточных правах пользователя. 
В совокупности эти классы формируют надёжную систему авторизации, которая основана на сторонних компонентах Spring Security и JWT.


В проекте предусмотрены механизмы обеспечения безопасности данных. Для защиты паролей пользователей используется компонент **PasswordEncoder** из фреймворка Spring Security, реализующий шифрование с помощью алгоритма **BCrypt**. Ниже представлен листинг кода, реализующий шифрование паролей пользователей.

	@Bean
	public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12);
	}
	public AppUser save(AppUser user) {
    if (repository.findByUsername(user.getUsername()).isPresent()) {
        throw new BadRequestException("Пользователь с таким логином уже суще-ствует");
    }
    user.setPassword(passwordEncoder.encode(user.getPassword()));
    if (findAll().isEmpty()) {
        user.setRole(Role.ADMIN);
    }
    return repository.save(user);
	}

В классе **SecurityConfiguration** создаётся бин **BCryptPasswordEncoder**, который реализует безопасное хэширование паролей. При регистрации нового пользователя в сервисе UserService его пароль перед сохранением в базу данных преобразуется в зашифрованный хэш с помощью метода passwordEncoder.encode(). При входе в систему Spring Security автоматически сравнивает введённый пользователем пароль с сохранённым хэшем, исполь-зуя метод passwordEncoder.matches(). Такой подход обеспечивает надёжное шифрование паролей и защищает данные от несанкционированного доступа.

Также в проекте реализован такой механизм безопасности, как система разграничения прав доступа на основе аннотаций **@Secured**. Контроллеры, например, UserController, ограничивают доступ к методам в зависимости от роли пользователя (ADMIN, USER и т.д.). Это обеспечивает защиту данных и функций приложения от несанкционированного использования. Ниже пред-ставлен фрагмент кода, демонстрирующий систему разграничения прав доступа.

	@Secured({ADMIN})
	@GetMapping("/all")
	public Result findAll() {
	    return new Result(
	            true,
	            StatusCode.SUCCESS,
	            "Success Find All",
	            ser-vice.findAll().stream().map(toDtoConverter::convert).collect(Collectors.toList())
	    );
	}
	@Secured({ADMIN, MANAGER, USER})
	@GetMapping
	public Result find() {
	    return new Result(
	            true,
	            StatusCode.SUCCESS,
	            "Success Find",
	            toDtoConverter.convert(service.getCurrentUser())
	    );
	}


Также реализована обработка ошибок безопасности. Для защиты от несанкционированного доступа и корректного информирования клиента исполь-зуются собственные обработчики ошибок – **CustomBearerTokenAuthentication-EntryPoint** и **CustomBearerTokenAccessDeniedHandler**. Они перехватывают ситуации, когда токен недействителен или у пользователя нет достаточных прав, и возвращают соответствующие HTTP-ответы (401 Unauthorized, 403 Forbidden). Ниже представлен скрипт кода, реализации данного механизма.

	@Component
	public class CustomBearerTokenAuthenticationEntryPoint implements Authentica-tionEntryPoint {
	
		private final HandlerExceptionResolver resolver;
	
	    public CustomBearerTokenAuthenticationEntry-Point(@Qualifier("handlerExceptionResolver") HandlerExceptionResolver resolv-er) {
	        this.resolver = resolver;
	    }
	
	    @Override
	    public void commence(HttpServletRequest request, HttpServletResponse re-sponse, AuthenticationException authException) {
	        resolver.resolveException(request, response, null, authException);
	    }
	}
	@Component
	public class CustomBearerTokenAccessDeniedHandler implements Access-DeniedHandler {
	
	    private final HandlerExceptionResolver resolver;
	
	    public CustomBearerTokenAccess-DeniedHandler(@Qualifier("handlerExceptionResolver") HandlerExceptionResolver resolver) {
	        this.resolver = resolver;
	    }
	
	    @Override
	    public void handle(HttpServletRequest request, HttpServletResponse re-sponse, AccessDeniedException accessDeniedException) {
	        resolver.resolveException(request, response, null, accessDeniedExcep-tion);
	    }
	}

Все эти механизмы в совокупности обеспечивают высокий уровень за-щиты данных и безопасную работу приложения.

### Оценка качества кода

Используя показатели качества и метрики кода, оценить его качество

---

## **Тестирование**

### Unit-тесты

Представить код тестов для пяти методов и его пояснение

### Интеграционные тесты

Представить код тестов и его пояснение

---

## **Установка и  запуск**

### Манифесты для сборки docker образов

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

### Манифесты для развертывания k8s кластера

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

---

## **Лицензия**

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [[License.md|LICENSE.md]]

---

## **Контакты**

Автор: vladaray010@gmail.com
