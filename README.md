# **Программное средство реализации онлайн-сервиса поиска автоперевозок в г.Минске**

**Описание проекта:**
Проект представляет собой программное средство для поиска автоперевозок в городе Минске. Система предназначена для автоматизации процесса подбора транспортных средств и водителей для перевозки грузов. Основой проекта является удобный сервис, который объединяет базу данных водителей, обеспечивая быстрый и точный поиск подходящих вариантов перевозки.

**Цели проекта:**
Главной целью проекта является снижение затрат времени на поиск автоперевозок в Минске. Данная система позволит сократить время на поиск и оформление перевозки, минимизировать ошибки при подборе транспорта и водителя.

**Основные возможности:**
Сервис предоставляет пользователям следующие функции: поиск доступных автомобилей для перевозки грузов с учетом веса, объема и маршрута; создание и управление заявками; расчет стоимости перевозки. Система также обеспечивает хранение и обработку информации о пользователях, водителях и транспортных средствах, а также возможность аналитики и формирования отчетов для оптимизации работы сервиса.

Ссылки на репозитории сервера и клиента
Сервер:https:[//github.com/vlada2202/TruckingServer.git](https://github.com/vlada2202/back.git)
Клиент:[https://github.com/vlada2202/TruckingClient.git](https://github.com/vlada2202/TruckingClient.git)
---

## **Содержание**

1. [Архитектура](#Архитектура)
	1. [C4-модель](#C4-модель)
	2. [Схема данных](#Схема_данных)
2. [Функциональные возможности](#Функциональные_возможности)
	1. [Диаграмма вариантов использования](#Диаграмма_вариантов_использования)
	2. [User-flow диаграммы](#User-flow_диаграммы)
3. [Пользовательский интерфейс](#Примеры экранов UI)
	1. [Пользовательский интерфейс](#Примеры экранов UI)
4. [Детали реализации](#Детали_реализации)
	1. [UML-диаграммы](#UML-диаграммы)
	2. [Спецификация API](#Спецификация_API)
	3. [Безопасность](#Безопасность)
	4. [Оценка качества кода](#Оценка_качества_кода)
    5. [Документация](#Документация)
5. [Тестирование](#Тестирование)
	1. [Unit-тесты](#Unit-тесты)
	2. [Интеграционные тесты](#Интеграционные_тесты)
6. [Установка и  запуск](#installation)
	1. [Манифесты для сборки docker образов](#Манифесты_для_сборки_docker_образов)
	2. [Манифесты для развертывания k8s кластера](#Манифесты_для_развертывания_k8s_кластера)
    3. [Манифесты для развертывания k8s кластера](#Манифесты_для_развертывания_k8s_кластера)
7. [Развертывание](#install)
8. [Лицензия](#Лицензия)
9. [Контакты](#Контакты)

---
## **Архитектура**

### C4-модель

**Контейнерный уровень архитектуры ПС**
	
  <img width="701" height="785" alt="image" src="https://github.com/user-attachments/assets/a882d565-d3f5-40ac-9284-642a92a1fb99" />

Онлайн-сервис поиска автоперевозчиков в г. Минск представлен как программное средство CarDeal, которое обеспечивает взаимодействие между тремя основными внешними участниками: заказчиками автоперевозок, автоперевозчиками и оператором сервиса.

Система включает несколько ключевых контейнеров. Основной элемент для взаимодействия пользователей с системой – это клиентское приложение, которое предоставляет интерфейс для удобной работы заказчиков и перевозчиков с сервисом, позволяя им формировать и просматривать заявки, управлять услугами.
Для обработки бизнес-логики и управления данными используется API-приложение, построенное на Spring Framework. Этот контейнер отвечает за приём запросов от клиентского приложения, их обработку и выполнение бизнес-правил.
Хранение данных реализовано в базе данных MySQL, которая содержит всю необходимую информацию об услугах, пользователях, перевозчиках и т.д. Доступ к базе данных осуществляется только через Backend, что обеспечивает централизованный контроль за чтением и записью данных, а также целостность информации в системе.
   
**Компонентный уровень архитектуры ПС**
   
<img width="1177" height="819" alt="image" src="https://github.com/user-attachments/assets/c1070722-f29a-4674-9d8c-d756dbf19067" />

На компонентном уровне система CarDeal детализируется как набор логически выделенных модулей, каждый из которых реализует отдельную часть бизнес-логики.
Клиентское приложение формирует пользовательский интерфейс и отвечает за отправку запросов к серверу для работы с системой.

На стороне сервера реализованы несколько специализированных компонентов (контроллеров):

1 **AuthController** – отвечает за регистрацию и авторизацию пользователей, а также за валидацию и выдачу JWT-токенов для безопасного доступа.

2 **ReviewController** – управляет отзывами пользователей: добавление, редактирование, удаление и просмотр отзывов.

3 **AdminController** – предоставляет возможности модерации и управления системой, включая контроль пользователей и содержимого.

4 **RequestController** – осуществляет управление заявками пользователей: создание, редактирование, удаление и просмотр заявок.

5 **CarrierController** – предоставляет автоперевозчикам инструменты для управления своими услугами и взаимодействия с клиентами: добавление, редактирование, удаление и просмотр услуг.

Все контроллеры взаимодействуют с соответствующими сервисами (**UserService, ReviewsService, AdminService, RequestsService, CarriersService**), которые инкапсулируют бизнес-логику, обеспечивая работу с данными.

Данные хранятся в базе данных MySQL, включающей информацию о пользователях, заявках, услугах и отзывах. Доступ к данным осуществляется централизованно через сервисы и контроллеры, что обеспечивает целостность и безопасность работы системы.

### Схема данных

<img width="624" height="420" alt="image" src="https://github.com/user-attachments/assets/3e58cdfd-96c1-45db-812d-30458f260780" />


**Диаграмма состояний**

<img width="429" height="319" alt="image" src="https://github.com/user-attachments/assets/f1bd137a-1c6c-4424-872c-b30f3c67af9d" />

**Диаграмма деятельности**

<img width="242" height="588" alt="image" src="https://github.com/user-attachments/assets/2e2bba2a-e953-47af-a96b-840a15957107" />

**Диаграмма классов, отображающая структуру пакета app_user**

<img width="3304" height="3080" alt="4" src="https://github.com/user-attachments/assets/4a575084-f55c-4a85-98ee-78ab7fa199bc" />

**Диаграмма классов, отображающая структуру пакета ordering_chat**

<img width="4072" height="4512" alt="2" src="https://github.com/user-attachments/assets/b91e9e2b-9652-4ce5-9fa0-fb66279339e7" />

**Диаграмма классов, отображающая структуру пакета ordering**

<img width="2394" height="2668" alt="3" src="https://github.com/user-attachments/assets/3f671ed2-7c27-41fd-9bd8-abad7b7f5909" />

---

## **Функциональные возможности**

### Диаграмма вариантов использования

<img width="471" height="295" alt="image" src="https://github.com/user-attachments/assets/73f6c9e7-ee90-462f-a473-9e72048e2614" />

Диаграмма вариантов использования отражает функциональные воз-можности программного средства для онлайн-сервиса поиска автоперевозчи-ков в г. Минске и взаимодействие между основными ролями системы. На диаграмме представлены три актёра: заказчик автоперевозок, автоперевозчик и оператор сервиса, каждый из которых выполняет свои уникальные действия в рамках приложения.

Заказчик автоперевозок является основным пользователем системы, который может создавать заявки на перевозку, просматривать доступных автоперевозчиков, отслеживать историю своих заявок, а также оставлять отзывы о выполненных перевозках. Эти варианты использования обеспечивают удобство поиска и взаимодействия с перевозчиками.

Автоперевозчик имеет возможность управлять своими заявками – одобрять, отклонять или выполнять их. Также он может редактировать дан-ные своего профиля, добавлять транспортные средства и обновлять информа-цию о них. Данные функции направлены на поддержку актуальности информации и эффективное взаимодействие с заказчиками.

Оператор сервиса выполняет административные функции: управляет пользователями системы, просматривает аналитику по автоперевозчикам и осуществляет модерацию контента. Его роль обеспечивает стабильную и без-опасную работу сервиса, а также поддержание порядка в пользовательских данных и отзывах.


### User-flow диаграммы

**User-flow диаграмма для заказчика автоперевозок**

<img width="5470" height="3526" alt="image" src="https://github.com/user-attachments/assets/567c87d5-ad9d-4d36-911c-a2b660272523" />

На представленной user-flow диаграмме показан процесс взаимодействия заказчика автоперевозок с системой. Рамками выделены основные бизнес-процессы: авторизация и регистрация пользователя, а также создание за-явки на перевозку. Диаграмма отражает ключевые этапы: вход или регистрацию пользователя, формирование заявки, выбор или поиск перевозчика, отслеживание статуса заказа. Стрелками обозначены переходы между шагами, что позволяет наглядно проследить весь путь пользователя от входа в систему до завершения перевозки и получения результата.

**User-flow диаграмма для автоперевозчика**

<img width="6072" height="2816" alt="image" src="https://github.com/user-attachments/assets/c9809ab9-cc33-4003-9f20-c498aa89a42d" />

На данной user-flow диаграмме представлена последовательность дей-ствий автоперевозчика при работе с системой. Рамками выделены основные бизнес-процессы: вход и регистрация пользователя, управление услугами и работа с заявками. Диаграмма отображает логику переходов между экранами – от авторизации и добавления услуг до создания, редактирования и просмот-ра заявок. Такая структура позволяет проследить полный путь пользователя в системе, определить ключевые точки взаимодействия и оптимизировать ин-терфейс для удобства и понятности работы заказчика.

**User-flow диаграмма для оператора сервиса**

<img width="4328" height="2308" alt="image" src="https://github.com/user-attachments/assets/8db0b96c-5eba-472a-9a6c-227da5e33862" />

На представленной user-flow диаграмме показан процесс взаимодей-ствия оператора сервиса с системой. Рамками выделены основные бизнес-процессы: авторизация оператора сервиса, управление пользователями и управление каталогом автоперевозчиков. Диаграмма отражает шаги входа в систему, проверки данных, а также дальнейшие действия администратора – изменение ролей пользователей, редактирование и удаление услуг или карто-чек перевозчиков. Такая схема обеспечивает наглядное понимание структуры работы системы.

---

## **Пользовательский интерфейс**

### Примеры экранов UI

Ниже представлены примеры экранов программного средства. 

<img width="624" height="281" alt="image" src="https://github.com/user-attachments/assets/63488fff-c0d6-4dd7-bd52-5966042b9cce" />
<br>

<img width="551" height="248" alt="image" src="https://github.com/user-attachments/assets/42f00c90-4730-4ace-85d7-6e1800d4ed88" />
<br>

<img width="417" height="194" alt="image" src="https://github.com/user-attachments/assets/db298dd1-7707-44b9-9369-f936a8210557" />
<br>

<img width="470" height="184" alt="image" src="https://github.com/user-attachments/assets/46f6cdec-4c2b-4eac-beed-85b0600c509b" />
<br>

<img width="512" height="200" alt="image" src="https://github.com/user-attachments/assets/e9a75740-6ec9-4423-b085-530a8f525e39" />
<br>

<img width="624" height="221" alt="image" src="https://github.com/user-attachments/assets/308ff081-78e5-487e-b44f-0fafc4892985" />
<br>

<img width="624" height="305" alt="image" src="https://github.com/user-attachments/assets/a0abb2d1-f5a6-4071-95a2-d9ad9cbcbb7e" />
<br>

<img width="497" height="234" alt="image" src="https://github.com/user-attachments/assets/e7646c1d-2625-463f-8b00-13612438376d" />
<br>

<img width="467" height="223" alt="image" src="https://github.com/user-attachments/assets/430bbc07-5dbe-46a6-9074-11d1cd58bf13" />
<br>

<img width="489" height="207" alt="image" src="https://github.com/user-attachments/assets/4b74bae0-3873-49ab-9713-5dbe25f9aeb0" />
<br>

<img width="624" height="314" alt="image" src="https://github.com/user-attachments/assets/367bd4ae-c09c-48c6-bd2f-2670e5ab2513" />
<br>

<img width="624" height="313" alt="image" src="https://github.com/user-attachments/assets/98dae3a0-40fa-4ba1-97ac-bdc4df728367" />
<br>

## **Детали реализации**

### UML-диаграммы

Представить все UML-диаграммы , которые позволят более точно понять структуру и детали реализации ПС

### Спецификация API

Представить описание реализованных функциональных возможностей ПС с использованием Open API (можно представить либо полный файл спецификации, либо ссылку на него)

### Безопасность

За реализацию механизма аутентификации отвечают такие классы как, UserService, MyUserPrincipal, AuthController, AuthService, JwtProvider, SecurityConfiguration.
Класс **UserService** загружает пользователя из базы данных по логину и реализует интерфейс **UserDetailsService**, который используется **Spring Security** для проверки учетных данных. Класс **MyUserPrincipal** является обёрткой над сущностью **AppUser** и передаёт системе безопасности информацию о логине, пароле и ролях пользователя. Контроллер **AuthController** обрабатывает запро-сы на вход в систему по адресу /users/login и возвращает клиенту JWT-токен. Класс **AuthService** отвечает за создание этого токена и сбор информации о пользователе, а **JwtProvider** непосредственно генерирует и подписывает JWT-токен с помощью RSA-ключа. Конфигурационный класс **SecurityConfiguration** задаёт общие правила безопасности приложения, включая фильтры, CORS-настройки, обработку токенов и шифрование паролей. 
Вместе эти классы обеспечивают процесс аутентификации, авторизации и безопасного доступа к ресурсам приложения.


За реализацию механизма авторизации отвечают такие классы, как SecurityConfiguration, JwtProvider, UserController, MyUserPrincipal, CustomBearerTokenAuthenticationEntryPoint/CustomBearerT-kenAccessDeniedHandler.
Класс **SecurityConfiguration** определяет основные правила авторизации, настраивает фильтрацию запросов, обработку JWT-токенов и механизм про-верки прав доступа. Компонент **JwtProvider** формирует и проверяет токены, включая в них роли пользователя (authorities), что позволяет системе без-опасности определять уровень доступа при обращении к защищённым ресурсам. Класс **UserController** использует аннотации @Secured({ROLE}) для огра-ничения доступа к методам контроллера в зависимости от роли пользователя. Класс **MyUserPrincipal** передаёт роли (GrantedAuthority) из сущности пользо-вателя в контекст безопасности Spring Security, обеспечивая корректное сопоставление прав. Дополнительные классы – **CustomBearerTokenAuthenticationEntryPoint** и **CustomBearerTokenAccessDeniedHandler** – обрабатывают ошибки доступа, возникающие при отсутствии авторизации или при недостаточных правах пользователя. 
В совокупности эти классы формируют надёжную систему авторизации, которая основана на сторонних компонентах Spring Security и JWT.


В проекте предусмотрены механизмы обеспечения безопасности данных. Для защиты паролей пользователей используется компонент **PasswordEncoder** из фреймворка Spring Security, реализующий шифрование с помощью алгоритма **BCrypt**. Ниже представлен листинг кода, реализующий шифрование паролей пользователей.

	@Bean
	public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12);
	}
	public AppUser save(AppUser user) {
    if (repository.findByUsername(user.getUsername()).isPresent()) {
        throw new BadRequestException("Пользователь с таким логином уже суще-ствует");
    }
    user.setPassword(passwordEncoder.encode(user.getPassword()));
    if (findAll().isEmpty()) {
        user.setRole(Role.ADMIN);
    }
    return repository.save(user);
	}

В классе **SecurityConfiguration** создаётся бин **BCryptPasswordEncoder**, который реализует безопасное хэширование паролей. При регистрации нового пользователя в сервисе UserService его пароль перед сохранением в базу данных преобразуется в зашифрованный хэш с помощью метода passwordEncoder.encode(). При входе в систему Spring Security автоматически сравнивает введённый пользователем пароль с сохранённым хэшем, исполь-зуя метод passwordEncoder.matches(). Такой подход обеспечивает надёжное шифрование паролей и защищает данные от несанкционированного доступа.

Также в проекте реализован такой механизм безопасности, как система разграничения прав доступа на основе аннотаций **@Secured**. Контроллеры, например, UserController, ограничивают доступ к методам в зависимости от роли пользователя (ADMIN, USER и т.д.). Это обеспечивает защиту данных и функций приложения от несанкционированного использования. Ниже пред-ставлен фрагмент кода, демонстрирующий систему разграничения прав доступа.

	@Secured({ADMIN})
	@GetMapping("/all")
	public Result findAll() {
	    return new Result(
	            true,
	            StatusCode.SUCCESS,
	            "Success Find All",
	            ser-vice.findAll().stream().map(toDtoConverter::convert).collect(Collectors.toList())
	    );
	}
	@Secured({ADMIN, MANAGER, USER})
	@GetMapping
	public Result find() {
	    return new Result(
	            true,
	            StatusCode.SUCCESS,
	            "Success Find",
	            toDtoConverter.convert(service.getCurrentUser())
	    );
	}


Также реализована обработка ошибок безопасности. Для защиты от несанкционированного доступа и корректного информирования клиента исполь-зуются собственные обработчики ошибок – **CustomBearerTokenAuthentication-EntryPoint** и **CustomBearerTokenAccessDeniedHandler**. Они перехватывают ситуации, когда токен недействителен или у пользователя нет достаточных прав, и возвращают соответствующие HTTP-ответы (401 Unauthorized, 403 Forbidden). Ниже представлен скрипт кода, реализации данного механизма.

	@Component
	public class CustomBearerTokenAuthenticationEntryPoint implements Authentica-tionEntryPoint {
	
		private final HandlerExceptionResolver resolver;
	
	    public CustomBearerTokenAuthenticationEntry-Point(@Qualifier("handlerExceptionResolver") HandlerExceptionResolver resolv-er) {
	        this.resolver = resolver;
	    }
	
	    @Override
	    public void commence(HttpServletRequest request, HttpServletResponse re-sponse, AuthenticationException authException) {
	        resolver.resolveException(request, response, null, authException);
	    }
	}
	@Component
	public class CustomBearerTokenAccessDeniedHandler implements Access-DeniedHandler {
	
	    private final HandlerExceptionResolver resolver;
	
	    public CustomBearerTokenAccess-DeniedHandler(@Qualifier("handlerExceptionResolver") HandlerExceptionResolver resolver) {
	        this.resolver = resolver;
	    }
	
	    @Override
	    public void handle(HttpServletRequest request, HttpServletResponse re-sponse, AccessDeniedException accessDeniedException) {
	        resolver.resolveException(request, response, null, accessDeniedExcep-tion);
	    }
	}

Все эти механизмы в совокупности обеспечивают высокий уровень за-щиты данных и безопасную работу приложения.

### Оценка качества кода

В ходе оценки качества разработанного кода было установлено, что ис-пользование многослойной архитектуры Spring Boot позволило достичь высоких показателей метрик, таких как «Высокая модульность» и «Хорошая согласованность компонентов». Разделение приложения на слои controller, service, repository и model обеспечило ясное распределение ответственности. В частности, бизнес-логика, реализованная в сервисных классах (например, OrderService и ReviewService), была инкапсулирована таким образом, что ме-тоды стали компактными и легко тестируемыми, что снизило сложность со-провождения проекта.

При анализе качества кода особое внимание было уделено сокращению шаблонного кода и улучшению читаемости с помощью библиотеки Lombok. Использование аннотаций @Getter, @Setter, @Builder и @AllArgsConstructor позволило значительно уменьшить количество ручного кода, связанного с доступом к полям и созданием конструкторов. Это положительно сказалось на поддерживаемости проекта, поскольку классы стали более компактными, а основное внимание разработчика сосредоточено на реализации бизнес-логики, а не на инфраструктурных деталях.

Для количественной оценки качества кода были использованы следующие метрики:

1 Cyclomatic Complexity – измеряет сложность методов, показывая количество возможных ветвлений. В проекте средняя сложность методов оставалась в диапазоне 2–5, что указывает на простоту понимания и тестирования кода.

2 Code Duplication – процент повторяющихся блоков кода. Использование Lombok и повторное использование утилитарных методов позволило снизить дублирование до минимального уровня (менее 5%).

3 Maintainability Index – показатель удобства сопровождения кода, рас-считанный с учётом количества строк, сложности и комментариев. Применение Lombok, компактных сервисных методов и структурированного разбиения на слои обеспечило высокий индекс поддерживаемости.

В целом использование Lombok вместе с контролем метрик качества кода способствовало сокращению объёма шаблонного кода, повышению читаемости и снижению когнитивной нагрузки на разработчика, что улучшило поддержку и расширяемость программного продукта.

Для оценки производительности разработанного приложения были про-ведены замеры времени запуска и отклика ключевых сервисов. Среднее время холодного старта приложения составило около 8 секунд, что является прием-лемым показателем для Spring Boot проекта с подключенными базами данных и внешними сервисами. Дополнительно измерялись показатели времени от-клика отдельных методов сервисного слоя, которые показали стабильные зна-чения в диапазоне 100–200 миллисекунд, что обеспечивает плавную работу API и предсказуемость поведения приложения под нагрузкой.

Проведённая оценка качества разработанного программного продукта показала, что многослойная архитектура Spring Boot и применение библиотеки Lombok обеспечивают высокую модульность, читаемость и поддерживаемость кода. Метрики сложности методов, дублирования кода и индекс сопро-вождаемости продемонстрировали хорошие показатели, свидетельствующие о низкой когнитивной нагрузке на разработчика и удобстве сопровождения проекта. Использование Lombok позволило существенно сократить шаблонный код, сосредоточив внимание на реализации бизнес-логики, а строгое разделение слоёв обеспечило ясное распределение ответственности между компонентами. Проведённые замеры производительности показали, что время запуска приложения составляет около 4 секунд, а отклик ключевых сервисов остаётся стабильным в диапазоне 100–200 миллисекунд, что обеспечивает эффективную работу API и предсказуемость поведения системы под нагрузкой. 

Таким образом, разработанное приложение соответствует современным стандартам качества кода и производительности, обладая высокой расширяемостью и устойчивостью к изменениям.

### Документация
Ссылка на файл с документацией для Postman: https://github.com/vlada2202/Trucking/blob/main/api-docs.json

---

## **Тестирование**

### Unit-тесты

	@Test
    void findAll_shouldReturnResultWithList() throws Exception {
        Ordering ordering = mock(Ordering.class);
        OrderingDto dto = mock(OrderingDto.class);

        when(service.findAll()).thenReturn(Collections.singletonList(ordering));
        when(toDtoConverter.convert(ordering)).thenReturn(dto);

        mockMvc.perform(get("/orderings"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Success Find All"))
                .andExpect(jsonPath("$.data[0]").exists());

        verify(service, times(1)).findAll();
        verify(toDtoConverter, times(1)).convert(ordering);
    }

Данный тест проверяет корректность работы контроллера при запросе всех заказов по маршруту GET/orderings. В тесте имитируется возвращение сервисом списка объектов Ordering, который затем преобразуется в DTO с помощью конвертера. В ответе ожидается статус 200 OK, сообщение "Success Find All" и наличие данных в массиве. Также тест проверяет, что сервисный метод findAll() и конвертация DTO были вызваны ровно один раз.

	@Test
    void find_shouldReturnResult() throws Exception {
        Ordering ordering = mock(Ordering.class);
        OrderingDto dto = mock(OrderingDto.class);

        when(service.find("1")).thenReturn(ordering);
        when(toDtoConverter.convert(ordering)).thenReturn(dto);

        mockMvc.perform(get("/orderings/1"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Success Find"))
                .andExpect(jsonPath("$.data").exists());

        verify(service).find("1");
        verify(toDtoConverter).convert(ordering);
    }
	
Данный тестовый метод предназначен для проверки получения одного конкретного заказа по идентификатору через эндпоинт GET/orderings/{id}. Модуль Mockito подготавливает ответ сервиса и конвертера, после чего выполняется запрос. Проверяется успешный статус 200 OK, корректное сообщение "Success Find", а также наличие объекта данных в ответе. Верификация подтверждает, что сервис корректно вызывался с параметром "1" и произошло преобразование результата в DTO.

	@Test
    void save_shouldReturnSavedResult() throws Exception {
        OrderingDto dto = mock(OrderingDto.class);
        Ordering ordering = mock(Ordering.class);
        Ordering saved = mock(Ordering.class);
        OrderingDto savedDto = mock(OrderingDto.class);

        when(toConverter.convert(any(OrderingDto.class))).thenReturn(ordering);
        when(service.save(ordering, "v1")).thenReturn(saved);
        when(toDtoConverter.convert(saved)).thenReturn(savedDto);

        mockMvc.perform(post("/orderings")
                        .param("vehicleId", "v1")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{}"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Success Save"))
                .andExpect(jsonPath("$.data").exists());

        verify(service).save(ordering, "v1");
        verify(toConverter).convert(any(OrderingDto.class));
        verify(toDtoConverter).convert(saved);
    }

Этот метод тестирует работу сохранения нового заказа через запрос POST/orderings. В ходе теста DTO-конвертер преобразует входящий JSON в объект Ordering, далее сервисный слой сохраняет его с привязкой к транспортному средству (vehicleId). После сохранения конвертер формирует DTO-ответ. Ожидаемый результат — статус 200 OK, сообщение "Success Save" и наличие сохранённого объекта в ответе. Также проверяется корректность вызовов сервисного слоя и конвертеров.

 	@Test
    void approved_shouldReturnResult() throws Exception {
        Ordering ordering = mock(Ordering.class);
        OrderingDto dto = mock(OrderingDto.class);

        when(service.approved("1")).thenReturn(ordering);
        when(toDtoConverter.convert(ordering)).thenReturn(dto);

        mockMvc.perform(patch("/orderings/1/approved"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Success Approved"))
                .andExpect(jsonPath("$.data").exists());

        verify(service).approved("1");
        verify(toDtoConverter).convert(ordering);
    }

Метод отвечает за проверку обновления статуса заказа на «одобрен». Выполняется запрос PATCH /orderings/{id}/approved. Сервис возвращает обновлённый объект заказа, который конвертируется в DTO. Тест проверяет успешный статус ответа 200 OK, сообщение "Success Approved" и присутствие данных. Верификация подтверждает вызов метода approved("1") и конвертацию результата.

	@Test
    void rejected_shouldReturnResult() throws Exception {
        Ordering ordering = mock(Ordering.class);
        OrderingDto dto = mock(OrderingDto.class);

        when(service.rejected("1")).thenReturn(ordering);
        when(toDtoConverter.convert(ordering)).thenReturn(dto);

        mockMvc.perform(patch("/orderings/1/rejected"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Success Rejected"))
                .andExpect(jsonPath("$.data").exists());

        verify(service).rejected("1");
        verify(toDtoConverter).convert(ordering);
    }

Данный тест проверяет обновление статуса заказа на «отклонён» по маршруту PATCH /orderings/{id}/rejected. Аналогично предыдущим методам, сервис возвращает обновлённый заказ, конвертер подготавливает DTO-объект, а тест фиксирует ответ контроллера. Ожидается статус 200 OK, текст "Success Rejected" и наличие блока данных. Также подтверждается корректность вызовов сервисного слоя и конвертера.

	 @Test
    void done_shouldReturnResult() throws Exception {
        Ordering ordering = mock(Ordering.class);
        OrderingDto dto = mock(OrderingDto.class);

        when(service.done("1")).thenReturn(ordering);
        when(toDtoConverter.convert(ordering)).thenReturn(dto);

        mockMvc.perform(patch("/orderings/1/done"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Success Done"))
                .andExpect(jsonPath("$.data").exists());

        verify(service).done("1");
        verify(toDtoConverter).convert(ordering);
    }

Данный тест проверяет работу функционала завершения заказа по пути PATCH /orderings/{id}/done. Сервисный слой имитирует изменение статуса на завершённый и возвращает обновлённый заказ, который преобразуется в DTO. Тест проверяет успешный статус 200 OK, соответствующее сообщение "Success Done" и наличие данных. Происходит верификация корректного вызова метода done("1") и операции преобразования результата в DTO.

### Интеграционные тесты

	@Test
    void save_shouldCreateUser() throws Exception {
        String json = """
                {
                  "username": "newUser",
                  "password": "1234",
                  "email": "email@mail.com"
                }
                """;

        mockMvc.perform(post("/users")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Success Save"))
                .andExpect(jsonPath("$.data").exists());
    }

Тестовый метод save_shouldCreateUser() предназначен для проверки корректности работы механизма сохранения нового пользователя через REST-контроллер. На первом этапе формируется JSON-объект, содержащий данные нового пользователя: имя, пароль и адрес электронной почты. Затем тест отправляет HTTP-запрос типа POST на эндпоинт /users, передавая сформированный JSON в теле запроса. После выполнения запроса проверяется статус ответа 200 OK, что подтверждает успешную обработку операции. Далее осуществляется валидация структуры возвращаемого JSON: поле message должно содержать текст "Success Save", а в блоке data обязан присутствовать объект с данными сохранённого пользователя. Таким образом, тест подтверждает корректность работы контроллера, успешное создание пользователя и правильность формирования ответа сервера.

	@Test
    @WithMockUser(username = "testuser", roles = {"ADMIN"})
    void findAll_shouldReturnUsers() throws Exception {
        mockMvc.perform(get("/users/all"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.flag").value(true))
                .andExpect(jsonPath("$.data[0].username").value("testuser"));
    }
Данный тест проверяет корректность выполнения запроса на получение списка всех пользователей системы. Для имитации авторизованного обращения используется аннотация @WithMockUser, благодаря которой запрос выполняется от имени пользователя с ролью ADMIN, имеющего доступ к запрашиваемому ресурсу. Тест выполняет HTTP-запрос типа GET по маршруту /users/all и ожидает успешный ответ со статусом 200 OK, указывающим на корректную обработку запроса.

---

## **Установка и  запуск**

### Манифесты для сборки docker образов

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

### Манифесты для развертывания k8s кластера

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

---

## **Развертывание**

Для успешной установки и запуска программного приложения необхо-димо наличие следующих компонентов: операционная система Windows версии 8 и выше; сервер базы данных MySQL; среда разработки Inteleji IDEA; любой веб-браузер; Node.js и npm.
	
**Последовательность установки.** Для установки разработанного про-граммного приложения необходимо выполнить следующие шаги:

– установить операционную систему Windows версии 8 и выше;

– установить и настроить Java;

– установить и настроить MySQL;

– установить и настроить Inteleji IDEA;

– установить и настроить любой веб-браузер;

– установить и настроить Node.js и npm;

– установить и настроить разработанное программное приложение.

Файл конфигурации application.yml содержит параметры подключения к базе данных. Ниже представлено содержимое файла application.yml.

	spring:
    servlet:
        multipart:
            max-file-size: 10MB
            max-request-size: 10MB

    datasource:
        url: jdbc:mysql://localhost:3307/avtoperevozki
        username: root
        password: root

    jpa:
        hibernate:
            ddl-auto: update
        show-sql: true
        properties:
            hibernate:
                dialect: org.hibernate.dialect.MySQL8Dialect

Данный блок конфигурации представляет собой настройки Spring-приложения, подключённого к базе данных MySQL и использующего Hibernate. Параметр «spring.datasource.url» указывает путь к базе данных «avtoperevozki», расположенной на локальном сервере по порту 3307. Под-ключение осуществляется под пользователем «root» с паролем «root». Настройка «spring.jpa.hibernate.ddl-auto=update» обеспечивает автоматиче-ское обновление структуры базы данных при запуске приложения, а параметр «show-sql=true» позволяет отображать SQL-запросы в консоли, что упрощает отладку. Определённый диалект «org.hibernate.dialect.MySQL8Dialect» указы-вает Hibernate, как именно взаимодействовать с СУБД MySQL 8. Также зада-ны ограничения на размер загружаемых файлов – до 10 МБ, что контролиру-ется параметрами «max-file-size» и «max-request-size», обеспечивая безопас-ность и стабильность при работе с загрузками.

**Запуск программного приложения.** Запуск программного приложения представляет собой завершающий этап разработки, при котором проверенное и готовое к использованию программное обеспечение приводится в рабочее состояние. На этом этапе осуществляется конфигурация окружения, подклю-чение к базе данных, настройка путей, параметров безопасности и других не-обходимых компонентов. 
Для запуска программного приложения необходимо выполнить следу-ющие шаги:
1 Подключиться к MySQL и создать новую базу данных. Для этого вы-полним следующую команду:

	CREATE DATABASE avtoperevozki

2 Затем необходимо запустить сервер в среде разработки Inteleji IDEA.
3 Далее необходимо запустить клиентскую часть. В Inteleji IDEA проект запускается через кнопку пуска. 
4 После запуска сервера и клиентской части необходимо перейти по ссылке, представленной в терминале. Данная ссылка откроется в любом веб-браузере. Программное приложение будет доступно по адресу http://localhost:4200.

---

## **Лицензия**

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [[License.md|LICENSE.md]]

---

## **Контакты**

Автор: vladaray010@gmail.com
